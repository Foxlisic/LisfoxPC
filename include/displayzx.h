#ifndef __DISPLAYZX_HFILE
#define __DISPLAYZX_HFILE

#include "avrio.h"
#include "tahoma.h"

extern const byte zxfont4[48][8] PROGMEM;
const byte zxfont4[48][8]  = {
    /* 20 */ { 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x04, 0x00 },
    /* 22 */ { 0xa0, 0xaa, 0xae, 0x0a, 0x0e, 0x0a, 0x00, 0x00 },
    /* 24 */ { 0x4a, 0xe2, 0x84, 0x44, 0x24, 0xe8, 0x4a, 0x00 },
    /* 26 */ { 0x46, 0xa2, 0xa4, 0x40, 0x50, 0xa0, 0xe0, 0x30 },
    /* 28 */ { 0x28, 0x44, 0x82, 0x82, 0x82, 0x44, 0x28, 0x00 },
    /* 2a */ { 0x00, 0xa4, 0x44, 0xee, 0x44, 0xa4, 0x00, 0x00 },
    /* 2c */ { 0x00, 0x00, 0x00, 0x0e, 0x00, 0x60, 0x20, 0x40 },
    /* 2e */ { 0x02, 0x02, 0x04, 0x04, 0x04, 0x48, 0x48, 0x00 },
    /* 30 */ { 0x44, 0xac, 0xe4, 0xe4, 0xa4, 0xa4, 0x4e, 0x00 },
    /* 32 */ { 0x44, 0xaa, 0x22, 0x44, 0x42, 0x8a, 0xe4, 0x00 },
    /* 34 */ { 0x2e, 0xa8, 0xac, 0xe2, 0x22, 0x2a, 0x24, 0x00 },
    /* 36 */ { 0x4e, 0xa2, 0x82, 0xc4, 0xa4, 0xa8, 0x48, 0x00 },
    /* 38 */ { 0x44, 0xaa, 0xaa, 0x46, 0xa2, 0xaa, 0x44, 0x00 },
    /* 3a */ { 0x00, 0x44, 0x44, 0x00, 0x00, 0x44, 0x44, 0x08 },
    /* 3c */ { 0x10, 0x20, 0x4e, 0x80, 0x4e, 0x20, 0x10, 0x00 },
    /* 3e */ { 0x84, 0x4a, 0x22, 0x14, 0x24, 0x40, 0x84, 0x00 },
    /* 40 */ { 0x44, 0xaa, 0xaa, 0xee, 0xea, 0x8a, 0x6a, 0x00 },
    /* 42 */ { 0xc4, 0xaa, 0xa8, 0xc8, 0xa8, 0xaa, 0xc4, 0x00 },
    /* 44 */ { 0xce, 0xa8, 0xa8, 0xac, 0xa8, 0xa8, 0xce, 0x00 },
    /* 46 */ { 0xe4, 0x8a, 0x88, 0xce, 0x8a, 0x8a, 0x84, 0x00 },
    /* 48 */ { 0xae, 0xa4, 0xa4, 0xe4, 0xa4, 0xa4, 0xae, 0x00 },
    /* 4a */ { 0x2a, 0x2a, 0x2c, 0x2c, 0x2a, 0xaa, 0x4a, 0x00 },
    /* 4c */ { 0x8a, 0x8e, 0x8e, 0x8e, 0x8a, 0x8a, 0xea, 0x00 },
    /* 4e */ { 0x2e, 0xaa, 0xea, 0xea, 0xea, 0xaa, 0xae, 0x00 },
    /* 50 */ { 0xc4, 0xaa, 0xaa, 0xca, 0x8a, 0x8a, 0x84, 0x02 },
    /* 52 */ { 0xc4, 0xaa, 0xa8, 0xc4, 0xa2, 0xaa, 0xa4, 0x00 },
    /* 54 */ { 0xea, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x4e, 0x00 },
    /* 56 */ { 0xaa, 0xaa, 0xaa, 0xaa, 0xae, 0x4e, 0x4a, 0x00 },
    /* 58 */ { 0xaa, 0xaa, 0xea, 0x44, 0xe4, 0xa4, 0xa4, 0x00 },
    /* 5a */ { 0xe6, 0x24, 0x44, 0x44, 0x44, 0x84, 0xe6, 0x00 },
    /* 5c */ { 0x06, 0x82, 0x82, 0x42, 0x42, 0x22, 0x26, 0x00 },
    /* 5e */ { 0x00, 0x40, 0xe0, 0xa0, 0x00, 0x00, 0x00, 0x0f },
    /* 60 */ { 0x60, 0x40, 0x2c, 0x02, 0x06, 0x0a, 0x06, 0x00 },
    /* 62 */ { 0x80, 0x80, 0xc4, 0xaa, 0xa8, 0xaa, 0xc4, 0x00 },
    /* 64 */ { 0x20, 0x20, 0x64, 0xaa, 0xae, 0xa8, 0x66, 0x00 },
    /* 66 */ { 0x20, 0x40, 0x46, 0xea, 0x4a, 0x46, 0x42, 0x0c },
    /* 68 */ { 0x84, 0x80, 0xcc, 0xa4, 0xa4, 0xa4, 0xa4, 0x00 },
    /* 6a */ { 0x28, 0x08, 0x2a, 0x2a, 0x2c, 0x2a, 0xaa, 0x40 },
    /* 6c */ { 0xc0, 0x40, 0x4a, 0x4e, 0x4e, 0x4a, 0xea, 0x00 },
    /* 6e */ { 0x00, 0x00, 0xc4, 0xaa, 0xaa, 0xaa, 0xa4, 0x00 },
    /* 70 */ { 0x00, 0x00, 0xc6, 0xaa, 0xaa, 0xc6, 0x82, 0x83 },
    /* 72 */ { 0x00, 0x00, 0xc6, 0xa8, 0x84, 0x82, 0x8c, 0x00 },
    /* 74 */ { 0x00, 0x40, 0xea, 0x4a, 0x4a, 0x4a, 0x26, 0x00 },
    /* 76 */ { 0x00, 0x00, 0xaa, 0xaa, 0xae, 0x4e, 0x4a, 0x00 },
    /* 78 */ { 0x00, 0x00, 0xaa, 0xaa, 0x4a, 0xa6, 0xa2, 0x0c },
    /* 7a */ { 0x02, 0x04, 0xe4, 0x28, 0x44, 0x84, 0xe2, 0x00 },
    /* 7c */ { 0x48, 0x44, 0x44, 0x02, 0x44, 0x44, 0x48, 0x00 },
    /* 7e */ { 0x50, 0xa0, 0x04, 0x04, 0x0a, 0x0a, 0x0e, 0x00 },
};

// Адрес для ZX Spectrum линии
extern  const word height[192] PROGMEM;
        const word height[192] =
{
    0x0000, 0x0100, 0x0200, 0x0300, 0x0400, 0x0500, 0x0600, 0x0700,
    0x0020, 0x0120, 0x0220, 0x0320, 0x0420, 0x0520, 0x0620, 0x0720,
    0x0040, 0x0140, 0x0240, 0x0340, 0x0440, 0x0540, 0x0640, 0x0740,
    0x0060, 0x0160, 0x0260, 0x0360, 0x0460, 0x0560, 0x0660, 0x0760,
    0x0080, 0x0180, 0x0280, 0x0380, 0x0480, 0x0580, 0x0680, 0x0780,
    0x00a0, 0x01a0, 0x02a0, 0x03a0, 0x04a0, 0x05a0, 0x06a0, 0x07a0,
    0x00c0, 0x01c0, 0x02c0, 0x03c0, 0x04c0, 0x05c0, 0x06c0, 0x07c0,
    0x00e0, 0x01e0, 0x02e0, 0x03e0, 0x04e0, 0x05e0, 0x06e0, 0x07e0,
    0x0800, 0x0900, 0x0a00, 0x0b00, 0x0c00, 0x0d00, 0x0e00, 0x0f00,
    0x0820, 0x0920, 0x0a20, 0x0b20, 0x0c20, 0x0d20, 0x0e20, 0x0f20,
    0x0840, 0x0940, 0x0a40, 0x0b40, 0x0c40, 0x0d40, 0x0e40, 0x0f40,
    0x0860, 0x0960, 0x0a60, 0x0b60, 0x0c60, 0x0d60, 0x0e60, 0x0f60,
    0x0880, 0x0980, 0x0a80, 0x0b80, 0x0c80, 0x0d80, 0x0e80, 0x0f80,
    0x08a0, 0x09a0, 0x0aa0, 0x0ba0, 0x0ca0, 0x0da0, 0x0ea0, 0x0fa0,
    0x08c0, 0x09c0, 0x0ac0, 0x0bc0, 0x0cc0, 0x0dc0, 0x0ec0, 0x0fc0,
    0x08e0, 0x09e0, 0x0ae0, 0x0be0, 0x0ce0, 0x0de0, 0x0ee0, 0x0fe0,
    0x1000, 0x1100, 0x1200, 0x1300, 0x1400, 0x1500, 0x1600, 0x1700,
    0x1020, 0x1120, 0x1220, 0x1320, 0x1420, 0x1520, 0x1620, 0x1720,
    0x1040, 0x1140, 0x1240, 0x1340, 0x1440, 0x1540, 0x1640, 0x1740,
    0x1060, 0x1160, 0x1260, 0x1360, 0x1460, 0x1560, 0x1660, 0x1760,
    0x1080, 0x1180, 0x1280, 0x1380, 0x1480, 0x1580, 0x1680, 0x1780,
    0x10a0, 0x11a0, 0x12a0, 0x13a0, 0x14a0, 0x15a0, 0x16a0, 0x17a0,
    0x10c0, 0x11c0, 0x12c0, 0x13c0, 0x14c0, 0x15c0, 0x16c0, 0x17c0,
    0x10e0, 0x11e0, 0x12e0, 0x13e0, 0x14e0, 0x15e0, 0x16e0, 0x17e0
};

class DisplayZX {
public:

    int loc_x, loc_y;

    DisplayZX() { loc_x = 0; loc_y = 0; }

    // Очистка экрана от скверны
    void cls(byte color = 0x00) {

        heapzx;
        outp(VMODE, VM_ZXSPECTRUM);

        for (int i = 0x0000; i < 0x1800; i++) vm[i] = 0;
        for (int i = 0x1800; i < 0x1B00; i++) vm[i] = color;

        border(color >> 3);
    }

    void loc(byte x, byte y) {
        loc_x = x;
        loc_y = y;
    }

    // Бордер
    void border(byte b) {
        outp(ZXBORD, b);
    }

    // Печать символа
    void tahoma(byte ch, byte overlap = 0) {

        heapzx;

        ch -= 32;

        word x0 = LPW(tahoma_offset[ch]);
        byte sz = LPM(tahoma_size[ch]);

        // Позиция символа в битовой карте
        if (loc_x + sz >= 256) {
            loc_x = 0;
            loc_y += 11;
        }

        word h  = x0    >> 3, l  = x0 & 7,
             cx = loc_x >> 3, cl = loc_x & 7;

        // Высота символа: 11 пикселей
        for (int i = 0; i < 11; i++) {

            // Получение данных и сдвиг на правильную позицию
            word st = (256*LPM(tahoma_bitmap[h]) + 1*LPM(tahoma_bitmap[h+1])) << l;

            // Выделить единичные биты слева
            word m1 = (0xFFF0000 >> sz);
            int  at = LPW(height[loc_y + i]) + cx;

            word  mk = st & m1;                     // Удалить лишние справа от символа
            dword td =  ( (dword) mk << 8) >> cl;   // Передвинуть
            dword tm = ~(((dword) m1 << 8) >> cl);  // Для удаления места под символом

            // Очистить фон картинки и наложить туда новый глиф
            if (overlap) {

                vm[at]   &= (tm >> 16);
                vm[at+1] &= (tm >>  8);
                vm[at+2] &= (tm >>  0);
            }

            vm[at]   |= (td >> 16);
            vm[at+1] |= (td >> 8);
            vm[at+2] |= (td >> 0);

            h += 112;
        }

        loc_x += sz;
    }

    // Установка точки
    void pset(byte x, byte y, byte cl) {

        if (y > 192) return;

        heapzx;

        // Вычисление положения точки
        word A = LPW(height[y]) + (x >> 3);
        byte M = 1 << ((7 ^ x) & 7);

        // Установка или очистка точки
        if      (cl == 0) vm[A] &= ~M;
        else if (cl == 2) vm[A] ^=  M;
        else              vm[A] |=  M;
    }

    // Печать 4x8
    void print4(const char* s) {

        byte ch;
        int i = 0;
        while((ch = s[i++])) font4(ch);
    }

    // Прочесть байт utf8/rus
    void print(const char* s, byte overlap = 0) {

        byte ch;
        int i = 0;

        while((ch = s[i++])) {

            // UTF8 Convert
            if      (ch == 0xD0) { ch = s[i++] - 0x10; if (ch == 0x71) ch = 0xC0; }
            else if (ch == 0xD1) { ch = s[i++] + 0x30; }

            tahoma(ch, overlap);
        }
    }

    // Вывод символа 4x8
    void font4(byte ch) {

        heapzx;

        int x = loc_x >> 2,
            y = 8*(loc_y >> 3);

        ch -= 32;
        x  &= 63;

        if (ch >= 96) ch = 0;

        byte M  = ch >> 1;
        byte x2 = x >> 1;
        word A  = LPW(height[y]) + x2;

        for (byte i = 0; i < 8; i++) {

            byte mask = LPM(zxfont4[M][i]);

            // Выбор номер символа
            if ((ch & 1) == 0) mask >>= 4;

            // Рисование в левой или правой стороне
            if (x & 1) {
                vm[A] = (vm[A] & 0xF0) | (mask & 15);
            } else {
                vm[A] = (vm[A] & 0x0F) | (mask << 4);
            }

            A += 0x100;
        }

        loc_x += 4;
    }

    // Рисовать линию на экране конечно же
    void line(int x1, int y1, int x2, int y2, byte cl) {

        // Инициализация смещений
        char signx  = x1 < x2 ? 1 : -1;
        char signy  = y1 < y2 ? 1 : -1;
        int  deltax = x2 > x1 ? x2 - x1 : x1 - x2;
        int  deltay = y2 > y1 ? y2 - y1 : y1 - y2;
        int  error  = deltax - deltay;
        int  error2;

        // Если линия - это точка
        pset(x2, y2, cl);

        // Перебирать до конца
        while ((x1 != x2) || (y1 != y2)) {

            pset(x1, y1, cl);

            error2 = 2 * error;
            if (error2 > -deltay) { error -= deltay; x1 += signx; } // X
            if (error2 <  deltax) { error += deltax; y1 += signy; } // Y
        }
    }

    // Ускоренное рисование блока по сравнению с линией
    void block(byte x1, byte y1, byte x2, byte y2, byte cl) {

        heapzx;

        word at;
        byte x1l = x1 & 7;
        byte x2l = x2 & 7;
        byte x1h = x1 >> 3;
        byte x2h = x2 >> 3;

        byte m0 = 0x00FF >> x1l;
        byte m1 = 0xFF80 >> x2l;

        // Находится на одной позиции
        if (x1h == x2h) {

            for (int y = y1; y <= y2; y++) {

                at = LPW(height[y]) + x1h;
                if (cl) vm[at] |= (m0 & m1); else vm[at] &= ~(m0 & m1);
            }
        }
        else {

            for (int y = y1; y <= y2; y++) {

                at = LPW(height[y]) + x1h;

                // Левая сторона
                if (cl) vm[at++] |=  (m0);
                else    vm[at++] &= ~(m0);

                // Посередине
                for (int x = x1h + 1; x < x2h; x++)
                    vm[at++] = cl ? 255 : 0;

                // Правая сторона
                if (cl) vm[at]   |=  (m1);
                else    vm[at++] &= ~(m1);
            }
        }
    }

    // Рисовать блок атрибутов
    void attrb(byte x1, byte y1, byte x2, byte y2, byte attr) {

        heapzx;
        for (byte y = y1; y <= y2; y++) {

            word a = 0x1800 + 32*(word)y + (word)x1;
            for (byte x = x1; x <= x2; x++) vm[a++] = attr;
        }
    }

};

#endif
